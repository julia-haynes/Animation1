<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Moon Crater Time Animation</title>

  <script src="https://d3js.org/d3.v7.min.js"></script>

  <style>
    body {
      background: #111;
      color: white;
      font-family: sans-serif;
      text-align: center;
    }
    #sliderContainer { margin-top: 20px; }
    input[type="range"] { width: 80%; }

    button {
      padding: 10px 20px;
      background: #444;
      color: white;
      border: none;
      font-size: 16px;
      cursor: pointer;
      border-radius: 6px;
      margin: 5px;
    }

    #cycleText {
      margin-top: 20px;
      font-size: 20px;
      font-weight: 300;
      color: #ddd;
      height: 30px;
    }

    #mareButtons {
      margin-top: 40px;
    }
  </style>
</head>

<body>
<h2>Moon Crater Evolution (TimeStep)</h2>

<button id="playBtn">▶ Play</button>

<div id="sliderContainer">
  <input id="timeSlider" type="range" min="0" max="100" value="0" step="1">
  <div>Current timestep: <span id="timeValue">0</span></div>
</div>

<div id="cycleText"></div>

<svg id="svg" width="800" height="800"></svg>

<script>
const width = 800, height = 800;
const svg = d3.select("#svg");

// Clear ANY circles on load
svg.selectAll("circle").remove();

// Projection
let projection = d3.geoOrthographic()
  .scale(350)
  .translate([width/2, height/2])
  .clipAngle(90)
  .rotate([-90, 0]);

const path = d3.geoPath().projection(projection);

// Draw sphere (this does NOT show craters)
svg.append("path")
  .datum({ type: "Sphere" })
  .attr("fill", "#222")
  .attr("stroke", "#888")
  .attr("d", path);

// Drag to rotate sphere
svg.call(
  d3.drag().on("drag", (event) => {
    const rot = projection.rotate();
    projection.rotate([rot[0] + event.dx * 0.25, rot[1] - event.dy * 0.25]);
    svg.select("path").attr("d", path);
    if (currentTimestep >= minT) update(currentTimestep);
  })
);

// --------------------
// Text phrases
// --------------------
const phrases = [
  "As craters form on the moon, they can be overlapped by other craters that are formed after",
  "When more than 75% of the crater has been overlapped, we call this process erasure",
  "Due to erasure, much of the history of crater evolution is lost",
  "We must create a model in order to simulate the evolution of craters on the moon",
  "As time goes on, the moon is overlapped by many craters that erase the history of the moon",
  "What we see on the moon today is only a fraction of the craters that have ever formed",
  "By studying crater evolution, we can better understand the history of the moon",
];

let phraseIndex = 0;
let phraseTimer = null;

function startPhraseCycle() {
  document.getElementById("cycleText").textContent = phrases[0];
  phraseIndex = 1;

  phraseTimer = setInterval(() => {
    document.getElementById("cycleText").textContent = phrases[phraseIndex];
    phraseIndex = (phraseIndex + 1) % phrases.length;
  }, 7000);
}

function stopPhraseCycle() {
  clearInterval(phraseTimer);
  phraseTimer = null;
}

// --------------------
// Load data
// --------------------
let minT, maxT;
let currentTimestep = -999; // ensure no craters appear initially

d3.json("animation_craters300k.json").then(data => {

  data.forEach(d => {
    d.Longitude = +d.Longitude;
    d.Latitude  = +d.Latitude;
    d.Size      = +d.Size;
    d.TimeStep  = +d.TimeStep;
  });

  minT = d3.min(data, d => d.TimeStep);
  maxT = d3.max(data, d => d.TimeStep);

  const slider = document.getElementById("timeSlider");
  slider.min = minT;
  slider.max = maxT;

  const radiusScale = d3.scaleSqrt()
    .domain([0.5, 600])
    .range([1, 40]);

  const totalSteps = Math.max(1, maxT - minT);
  const totalDurationMs = 40000;
  const stepDuration = totalDurationMs / totalSteps;

  // --------------------
  // Update function (draws craters)
  // --------------------
  function update(t) {
    const filtered = data.filter(d => d.TimeStep <= t);

    const circles = svg.selectAll("circle.survived")
      .data(filtered, d => d.Longitude + "_" + d.Latitude);

    circles.exit()
      .transition().duration(stepDuration * 0.7)
      .attr("r", 0)
      .remove();

    circles.enter()
      .append("circle")
      .attr("class", "survived")
      .attr("fill", "white")
      .attr("opacity", 0.9)
      .attr("r", 0)
      .attr("cx", d => projection([d.Longitude, d.Latitude])[0])
      .attr("cy", d => projection([d.Longitude, d.Latitude])[1])
      .merge(circles)
      .transition().duration(stepDuration)
      .attr("r", d => radiusScale(d.Size / 2))
      .attr("cx", d => projection([d.Longitude, d.Latitude])[0])
      .attr("cy", d => projection([d.Longitude, d.Latitude])[1]);
  }

  // --------------------
  // Slider: does nothing unless animation already started
  // --------------------
  slider.addEventListener("input", () => {
    currentTimestep = +slider.value;
    document.getElementById("timeValue").textContent = currentTimestep;
    if (currentTimestep >= minT) update(currentTimestep);
  });

  // --------------------
  // Play button
  // --------------------
  let playing = false;
  let timer = null;

  document.getElementById("playBtn").addEventListener("click", () => {

    if (!playing) {
      playing = true;
      document.getElementById("playBtn").textContent = "⏸ Pause";

      startPhraseCycle();

      // Reset animation and show NOTHING yet
      currentTimestep = minT - 1;
      slider.value = minT;
      document.getElementById("timeValue").textContent = minT;

      timer = setInterval(() => {
        currentTimestep++;

        if (currentTimestep < minT) return; // ensures timestep 0 appears FIRST

        if (currentTimestep > maxT) {
          clearInterval(timer);
          stopPhraseCycle();
          playing = false;
          document.getElementById("playBtn").textContent = "▶ Play";
          return;
        }

        slider.value = currentTimestep;
        document.getElementById("timeValue").textContent = currentTimestep;
        update(currentTimestep);

      }, stepDuration);

    } else {
      playing = false;
      document.getElementById("playBtn").textContent = "▶ Play";
      clearInterval(timer);
      stopPhraseCycle();
    }
  });

});
</script>

<!-- Buttons linking to mare-specific animations -->
<div id="mareButtons">
  <button onclick="location.href='oceanus.html'">Click here to view Oceanus Procellarum</button>
  <button onclick="location.href='imbrium.html'">Click here to view Mare Imbrium</button>
  <button onclick="location.href='tranq.html'">Click here to view Mare Tranquillitatis</button>
</div>

</body>
</html>
